# Объяснение Docker и Docker Compose

## Что такое Docker?

**Docker** — это платформа для контейнеризации приложений. Представьте, что это как "виртуальная коробка" для вашего приложения со всем необходимым внутри.

### Основные понятия:

1. **Образ (Image)** — шаблон/рецепт для создания контейнера
   - Например: `postgres:15-alpine` — готовый образ PostgreSQL
   - Например: ваш `Dockerfile` создает образ для бота

2. **Контейнер (Container)** — запущенный экземпляр образа
   - Это "живое" приложение, работающее изолированно

3. **Dockerfile** — инструкция, как собрать образ
   - Описывает, что нужно установить и как запустить приложение

4. **docker-compose.yml** — описание нескольких связанных контейнеров
   - Оркестрирует запуск нескольких сервисов вместе

---

## Что делает команда `docker-compose up -d`?

### Разбор команды:

```bash
docker-compose up -d
```

- `docker-compose` — утилита для управления несколькими контейнерами
- `up` — команда "поднять" (запустить) сервисы
- `-d` — флаг "detached mode" (в фоновом режиме, без блокировки терминала)

### Что происходит при выполнении:

1. **Чтение docker-compose.yml** — Docker Compose читает файл и видит 3 сервиса:
   - `postgres` — база данных
   - `pgadmin` — веб-интерфейс для БД
   - `bot` — ваш Telegram бот

2. **Проверка образов:**
   - Для `postgres` и `pgadmin` — использует готовые образы из Docker Hub
   - Для `bot` — проверяет, есть ли уже собранный образ, если нет — собирает из `Dockerfile`

3. **Создание сети:**
   - Создает виртуальную сеть `bot_network`
   - Все контейнеры могут общаться друг с другом по именам

4. **Создание volume (тома):**
   - Создает `postgres_data` — место для хранения данных БД

5. **Запуск контейнеров в правильном порядке:**
   - Сначала `postgres` (так как `bot` и `pgadmin` зависят от него)
   - Ждет, пока `postgres` станет здоровым (healthcheck)
   - Затем `pgadmin` (зависит от `postgres`)
   - Затем `bot` (зависит от `postgres`)

6. **Результат:**
   - Все 3 контейнера работают в фоне
   - PostgreSQL доступен на `localhost:5432`
   - pgAdmin доступен на `http://localhost:5050`
   - Бот работает внутри контейнера

---

## Поэтапный запуск сервисов

### Вариант 1: Запустить только базу и админку

```bash
docker-compose up -d postgres pgadmin
```

**Что происходит:**
- Запускаются только `postgres` и `pgadmin`
- `bot` не запускается (он не указан в команде)
- База данных готова к использованию

### Вариант 2: Потом запустить бота отдельно

```bash
# Сначала запустили базу и админку
docker-compose up -d postgres pgadmin

# Потом запускаем бота
docker-compose up -d bot
```

**Что происходит:**
- Docker Compose видит, что `postgres` и `pgadmin` уже запущены
- Проверяет зависимости: `bot` зависит от `postgres`
- Проверяет healthcheck `postgres` (если он здоров)
- Запускает `bot` контейнер
- Бот подключается к уже работающей базе данных

**Преимущества такого подхода:**
- Можно сначала убедиться, что база работает
- Можно проверить подключение через pgAdmin
- Потом запустить бота, когда все готово

---

## Связь между Dockerfile и docker-compose.yml

### Dockerfile — "Рецепт" для образа бота

```dockerfile
FROM python:3.12-slim          # Базовый образ (Python 3.12)
WORKDIR /app                   # Рабочая директория
COPY requirements.txt .        # Копируем зависимости
RUN pip install ...            # Устанавливаем библиотеки
COPY . .                       # Копируем код
CMD ["python", "bot.py"]       # Команда запуска
```

**Dockerfile описывает:**
- Какой базовый образ использовать
- Что установить
- Какой код скопировать
- Как запустить приложение

### docker-compose.yml — "Оркестратор" всех сервисов

```yaml
services:
  bot:
    build:
      context: .              # Где искать Dockerfile
      dockerfile: Dockerfile   # Какой файл использовать
    environment:              # Переменные окружения
      DB_HOST: postgres       # Бот знает, что БД называется "postgres"
```

**docker-compose.yml описывает:**
- Какие сервисы нужны (postgres, pgadmin, bot)
- Как их связать (сеть, зависимости)
- Какие переменные окружения передать
- Какие порты открыть

### Как они работают вместе:

1. **При первом запуске `docker-compose up`:**
   ```
   docker-compose.yml → видит секцию `bot` → видит `build:`
   → читает Dockerfile → собирает образ → создает контейнер
   ```

2. **При последующих запусках:**
   ```
   docker-compose.yml → видит, что образ уже есть → использует его
   ```

3. **Связь через имена:**
   - В `docker-compose.yml` сервис `postgres` получает имя `postgres`
   - В `docker-compose.yml` бот видит `DB_HOST: postgres`
   - Docker Compose автоматически резолвит имя `postgres` в IP адрес контейнера
   - Бот подключается к базе по имени `postgres` (не по localhost!)

---

## Практические примеры

### Пример 1: Полный запуск всего

```bash
docker-compose up -d
```

**Результат:**
- Все 3 контейнера запущены
- Бот работает и подключен к базе

### Пример 2: Запуск только базы для разработки

```bash
# Запускаем только базу
docker-compose up -d postgres

# Запускаем бота локально (не в Docker)
python bot.py
```

**Результат:**
- База работает в Docker
- Бот работает на вашем компьютере
- Бот подключается к `localhost:5432` (порт проброшен наружу)

### Пример 3: Пересборка образа бота

```bash
# Если изменили код или Dockerfile
docker-compose build bot      # Пересобрать образ
docker-compose up -d bot      # Перезапустить контейнер
```

### Пример 4: Просмотр логов

```bash
docker-compose logs -f bot    # Логи бота
docker-compose logs -f postgres  # Логи базы
```

### Пример 5: Остановка

```bash
docker-compose down           # Остановить все и удалить контейнеры
docker-compose stop           # Остановить, но не удалять
docker-compose restart bot    # Перезапустить только бота
```

---

## Важные моменты

### 1. Имена сервисов = DNS имена

В `docker-compose.yml`:
- Сервис `postgres` доступен по имени `postgres` внутри сети
- Бот подключается к `DB_HOST=postgres` (не `localhost`!)
- Снаружи (с вашего компьютера) база доступна на `localhost:5432`

### 2. Volumes сохраняют данные

```yaml
volumes:
  - postgres_data:/var/lib/postgresql/data
```

- Данные БД хранятся в volume `postgres_data`
- Даже если контейнер удалить, данные останутся
- При перезапуске данные восстановятся

### 3. Зависимости (depends_on)

```yaml
bot:
  depends_on:
    postgres:
      condition: service_healthy
```

- Бот не запустится, пока база не станет здоровой
- Docker Compose ждет прохождения healthcheck

### 4. Переменные окружения

```yaml
environment:
  DB_HOST: ${DB_HOST:-postgres}
```

- `${DB_HOST:-postgres}` означает: взять из `.env` или использовать `postgres`
- Переменные из `.env` автоматически подставляются

---

## Схема работы

```
┌─────────────────────────────────────────┐
│         docker-compose.yml               │
│  ┌──────────┐  ┌──────────┐  ┌──────┐  │
│  │ postgres │  │ pgadmin  │  │ bot  │  │
│  │ (image)  │  │ (image)  │  │(build)│  │
│  └────┬─────┘  └────┬─────┘  └───┬──┘  │
│       │             │            │     │
│       └─────────────┴────────────┘     │
│              bot_network                │
└─────────────────────────────────────────┘
           │                    │
           │                    │
    ┌──────▼──────┐      ┌──────▼──────┐
    │  localhost  │      │  localhost  │
    │   :5432     │      │   :5050     │
    │  (PostgreSQL)│      │  (pgAdmin)  │
    └─────────────┘      └─────────────┘
```

---

## Резюме

1. **Dockerfile** = рецепт для создания образа вашего бота
2. **docker-compose.yml** = оркестратор, который запускает все сервисы вместе
3. **`docker-compose up -d`** = запустить все сервисы в фоне
4. Можно запускать сервисы по отдельности — они автоматически найдут друг друга по именам
5. Имена сервисов работают как DNS внутри Docker сети

